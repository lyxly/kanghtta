<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on March, 20 2010 by texi2html 1.78 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>

-->
<head>
<title>Multiboot Specification: 3. The exact definitions of Multiboot Specification</title>

<meta name="description" content="Multiboot Specification: 3. The exact definitions of Multiboot Specification">
<meta name="keywords" content="Multiboot Specification: 3. The exact definitions of Multiboot Specification">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.78">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Specification"></a>
<a name="SEC10"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="multiboot_2.html#SEC9" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC11" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="multiboot_2.html#SEC9" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="multiboot.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="multiboot_4.html#SEC18" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="multiboot.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_6.html#SEC30" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 3. The exact definitions of Multiboot Specification </h1>

<p>There are three main aspects of a boot loader/OS image interface:
</p>
<ol>
<li>
The format of an OS image as seen by a boot loader.

</li><li>
The state of a machine when a boot loader starts an operating
system.

</li><li>
The format of information passed by a boot loader to an operating
system.
</li></ol>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC11">3.1 OS image format</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">             
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC16">3.2 Machine state</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC17">3.3 Boot information format</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">     
</td></tr>
</table>


<hr size="6">
<a name="OS-image-format"></a>
<a name="SEC11"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC10" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC12" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC10" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC10" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="multiboot_4.html#SEC18" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="multiboot.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_6.html#SEC30" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.1 OS image format </h2>

<p>An OS image may be an ordinary 32-bit executable file in the standard
format for that particular operating system, except that it may be
linked at a non-default load address to avoid loading on top of the
<small>PC</small>'s I/O region or other reserved areas, and of course it should
not use shared libraries or other fancy features.
</p>
<p>An OS image must contain an additional header called <em>Multiboot
header</em>, besides the headers of the format used by the OS image. The
Multiboot header must be contained completely within the first 8192
bytes of the OS image, and must be longword (32-bit) aligned. In
general, it should come <em>as early as possible</em>, and may be
embedded in the beginning of the text segment after the <em>real</em>
executable header.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC12">3.1.1 The layout of Multiboot header</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC13">3.1.2 The magic fields of Multiboot header</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC14">3.1.3 The address fields of Multiboot header</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC15">3.1.4 The graphics fields of Multiboot header</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">      
</td></tr>
</table>


<hr size="6">
<a name="Header-layout"></a>
<a name="SEC12"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC11" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC13" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC10" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC11" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="multiboot_4.html#SEC18" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="multiboot.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_6.html#SEC30" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 3.1.1 The layout of Multiboot header </h3>

<p>The layout of the Multiboot header must be as follows:
</p>
<table>
<tr><td><p> Offset </p></td><td><p> Type  </p></td><td><p> Field Name    </p></td><td><p> Note
</p></td></tr>
<tr><td><p> 0      </p></td><td><p> u32 </p></td><td><p> magic         </p></td><td><p> required
</p></td></tr>
<tr><td><p> 4      </p></td><td><p> u32 </p></td><td><p> flags         </p></td><td><p> required
</p></td></tr>
<tr><td><p> 8      </p></td><td><p> u32 </p></td><td><p> checksum      </p></td><td><p> required
</p></td></tr>
<tr><td><p> 12     </p></td><td><p> u32 </p></td><td><p> header_addr   </p></td><td><p> if flags[16] is set
</p></td></tr>
<tr><td><p> 16     </p></td><td><p> u32 </p></td><td><p> load_addr     </p></td><td><p> if flags[16] is set
</p></td></tr>
<tr><td><p> 20     </p></td><td><p> u32 </p></td><td><p> load_end_addr </p></td><td><p> if flags[16] is set
</p></td></tr>
<tr><td><p> 24     </p></td><td><p> u32 </p></td><td><p> bss_end_addr  </p></td><td><p> if flags[16] is set
</p></td></tr>
<tr><td><p> 28     </p></td><td><p> u32 </p></td><td><p> entry_addr    </p></td><td><p> if flags[16] is set
</p></td></tr>
<tr><td><p> 32     </p></td><td><p> u32 </p></td><td><p> mode_type     </p></td><td><p> if flags[2] is set
</p></td></tr>
<tr><td><p> 36     </p></td><td><p> u32 </p></td><td><p> width         </p></td><td><p> if flags[2] is set
</p></td></tr>
<tr><td><p> 40     </p></td><td><p> u32 </p></td><td><p> height        </p></td><td><p> if flags[2] is set
</p></td></tr>
<tr><td><p> 44     </p></td><td><p> u32 </p></td><td><p> depth         </p></td><td><p> if flags[2] is set
</p></td></tr>
</table>

<p>The fields &lsquo;<samp>magic</samp>&rsquo;, &lsquo;<samp>flags</samp>&rsquo; and &lsquo;<samp>checksum</samp>&rsquo; are defined in
<a href="#SEC13">The magic fields of Multiboot header</a>, the fields &lsquo;<samp>header_addr</samp>&rsquo;,
&lsquo;<samp>load_addr</samp>&rsquo;, &lsquo;<samp>load_end_addr</samp>&rsquo;, &lsquo;<samp>bss_end_addr</samp>&rsquo; and
&lsquo;<samp>entry_addr</samp>&rsquo; are defined in <a href="#SEC14">The address fields of Multiboot header</a>, and the
fields &lsquo;<samp>mode_type</samp>&rsquo;, &lsquo;<samp>width</samp>&rsquo;, &lsquo;<samp>height</samp>&rsquo; and &lsquo;<samp>depth</samp>&rsquo; are
defind in <a href="#SEC15">The graphics fields of Multiboot header</a>.
</p>

<hr size="6">
<a name="Header-magic-fields"></a>
<a name="SEC13"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC12" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC14" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC10" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC11" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="multiboot_4.html#SEC18" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="multiboot.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_6.html#SEC30" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 3.1.2 The magic fields of Multiboot header </h3>

<dl compact="compact">
<dt> &lsquo;<samp>magic</samp>&rsquo;</dt>
<dd><p>The field &lsquo;<samp>magic</samp>&rsquo; is the magic number identifying the header,
which must be the hexadecimal value <code>0x1BADB002</code>.
</p>
</dd>
<dt> &lsquo;<samp>flags</samp>&rsquo;</dt>
<dd><p>The field &lsquo;<samp>flags</samp>&rsquo; specifies features that the OS image requests or
requires of an boot loader. Bits 0-15 indicate requirements; if the
boot loader sees any of these bits set but doesn't understand the flag
or can't fulfill the requirements it indicates for some reason, it must
notify the user and fail to load the OS image. Bits 16-31 indicate
optional features; if any bits in this range are set but the boot loader
doesn't understand them, it may simply ignore them and proceed as
usual. Naturally, all as-yet-undefined bits in the &lsquo;<samp>flags</samp>&rsquo; word
must be set to zero in OS images. This way, the &lsquo;<samp>flags</samp>&rsquo; fields
serves for version control as well as simple feature selection.
</p>
<p>If bit 0 in the &lsquo;<samp>flags</samp>&rsquo; word is set, then all boot modules loaded
along with the operating system must be aligned on page (4KB)
boundaries. Some operating systems expect to be able to map the pages
containing boot modules directly into a paged address space during
startup, and thus need the boot modules to be page-aligned.
</p>
<p>If bit 1 in the &lsquo;<samp>flags</samp>&rsquo; word is set, then information on available
memory via at least the &lsquo;<samp>mem_*</samp>&rsquo; fields of the Multiboot information
structure (see section <a href="#SEC17">Boot information format</a>) must be included. If the
boot loader is capable of passing a memory map (the &lsquo;<samp>mmap_*</samp>&rsquo; fields)
and one exists, then it may be included as well.
</p>
<p>If bit 2 in the &lsquo;<samp>flags</samp>&rsquo; word is set, information about the video
mode table (see section <a href="#SEC17">Boot information format</a>) must be available to the
kernel.
</p>
<p>If bit 16 in the &lsquo;<samp>flags</samp>&rsquo; word is set, then the fields at offsets
12-28 in the Multiboot header are valid, and the boot loader should use
them instead of the fields in the actual executable header to calculate
where to load the OS image. This information does not need to be
provided if the kernel image is in <small>ELF</small> format, but it <em>must</em>
be provided if the images is in a.out format or in some other
format. Compliant boot loaders must be able to load images that either
are in <small>ELF</small> format or contain the load address information embedded
in the Multiboot header; they may also directly support other executable
formats, such as particular a.out variants, but are not required to.
</p>
</dd>
<dt> &lsquo;<samp>checksum</samp>&rsquo;</dt>
<dd><p>The field &lsquo;<samp>checksum</samp>&rsquo; is a 32-bit unsigned value which, when added
to the other magic fields (i.e. &lsquo;<samp>magic</samp>&rsquo; and &lsquo;<samp>flags</samp>&rsquo;), must
have a 32-bit unsigned sum of zero.
</p></dd>
</dl>


<hr size="6">
<a name="Header-address-fields"></a>
<a name="SEC14"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC13" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC15" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC10" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC11" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="multiboot_4.html#SEC18" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="multiboot.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_6.html#SEC30" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 3.1.3 The address fields of Multiboot header </h3>

<p>All of the address fields enabled by flag bit 16 are physical addresses.
The meaning of each is as follows:
</p>
<dl compact="compact">
<dt> <code>header_addr</code></dt>
<dd><p>Contains the address corresponding to the beginning of the Multiboot
header &mdash; the physical memory location at which the magic value is
supposed to be loaded. This field serves to <em>synchronize</em> the
mapping between OS image offsets and physical memory addresses.
</p>
</dd>
<dt> <code>load_addr</code></dt>
<dd><p>Contains the physical address of the beginning of the text segment. The
offset in the OS image file at which to start loading is defined by the
offset at which the header was found, minus (header_addr -
load_addr). load_addr must be less than or equal to header_addr.
</p>
</dd>
<dt> <code>load_end_addr</code></dt>
<dd><p>Contains the physical address of the end of the data
segment. (load_end_addr - load_addr) specifies how much data to load.
This implies that the text and data segments must be consecutive in the
OS image; this is true for existing a.out executable formats.
If this field is zero, the boot loader assumes that the text and data
segments occupy the whole OS image file.
</p>
</dd>
<dt> <code>bss_end_addr</code></dt>
<dd><p>Contains the physical address of the end of the bss segment. The boot
loader initializes this area to zero, and reserves the memory it
occupies to avoid placing boot modules and other data relevant to the
operating system in that area. If this field is zero, the boot loader
assumes that no bss segment is present.
</p>
</dd>
<dt> <code>entry_addr</code></dt>
<dd><p>The physical address to which the boot loader should jump in order to
start running the operating system.
</p></dd>
</dl>


<hr size="6">
<a name="Header-graphics-fields"></a>
<a name="SEC15"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC14" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC16" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC10" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC11" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="multiboot_4.html#SEC18" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="multiboot.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_6.html#SEC30" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 3.1.4 The graphics fields of Multiboot header </h3>

<p>All of the graphics fields are enabled by flag bit 2. They specify the
preferred graphics mode. Note that that is only a <em>recommended</em>
mode by the OS image. If the mode exists, the boot loader should set
it, when the user doesn't specify a mode explicitly. Otherwise, the
boot loader should fall back to a similar mode, if available.
</p>
<p>The meaning of each is as follows:
</p>
<dl compact="compact">
<dt> <code>mode_type</code></dt>
<dd><p>Contains &lsquo;<samp>0</samp>&rsquo; for linear graphics mode or &lsquo;<samp>1</samp>&rsquo; for
EGA-standard text mode. Everything else is reserved for future
expansion. Note that the boot loader may set a text mode, even if this
field contains &lsquo;<samp>0</samp>&rsquo;.
</p>
</dd>
<dt> <code>width</code></dt>
<dd><p>Contains the number of the columns. This is specified in pixels in a
graphics mode, and in characters in a text mode. The value zero
indicates that the OS image has no preference.
</p>
</dd>
<dt> <code>height</code></dt>
<dd><p>Contains the number of the lines. This is specified in pixels in a
graphics mode, and in characters in a text mode. The value zero
indicates that the OS image has no preference.
</p>
</dd>
<dt> <code>depth</code></dt>
<dd><p>Contains the number of bits per pixel in a graphics mode, and zero in
a text mode. The value zero indicates that the OS image has no
preference.
</p></dd>
</dl>


<hr size="6">
<a name="Machine-state"></a>
<a name="SEC16"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC15" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC17" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC10" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC10" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="multiboot_4.html#SEC18" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="multiboot.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_6.html#SEC30" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.2 Machine state </h2>

<p>When the boot loader invokes the 32-bit operating system, the machine
must have the following state:
</p>
<dl compact="compact">
<dt> &lsquo;<samp>EAX</samp>&rsquo;</dt>
<dd><p>Must contain the magic value &lsquo;<samp>0x2BADB002</samp>&rsquo;; the presence of this
value indicates to the operating system that it was loaded by a
Multiboot-compliant boot loader (e.g. as opposed to another type of
boot loader that the operating system can also be loaded from).
</p>
</dd>
<dt> &lsquo;<samp>EBX</samp>&rsquo;</dt>
<dd><p>Must contain the 32-bit physical address of the Multiboot
information structure provided by the boot loader (see section <a href="#SEC17">Boot information format</a>).
</p>
</dd>
<dt> &lsquo;<samp>CS</samp>&rsquo;</dt>
<dd><p>Must be a 32-bit read/execute code segment with an offset of &lsquo;<samp>0</samp>&rsquo;
and a limit of &lsquo;<samp>0xFFFFFFFF</samp>&rsquo;. The exact value is undefined.
</p>
</dd>
<dt> &lsquo;<samp>DS</samp>&rsquo;</dt>
<dt> &lsquo;<samp>ES</samp>&rsquo;</dt>
<dt> &lsquo;<samp>FS</samp>&rsquo;</dt>
<dt> &lsquo;<samp>GS</samp>&rsquo;</dt>
<dt> &lsquo;<samp>SS</samp>&rsquo;</dt>
<dd><p>Must be a 32-bit read/write data segment with an offset of &lsquo;<samp>0</samp>&rsquo;
and a limit of &lsquo;<samp>0xFFFFFFFF</samp>&rsquo;. The exact values are all undefined.
</p>
</dd>
<dt> &lsquo;<samp>A20 gate</samp>&rsquo;</dt>
<dd><p>Must be enabled.
</p>
</dd>
<dt> &lsquo;<samp>CR0</samp>&rsquo;</dt>
<dd><p>Bit 31 (PG) must be cleared. Bit 0 (PE) must be set. Other bits are
all undefined.
</p>
</dd>
<dt> &lsquo;<samp>EFLAGS</samp>&rsquo;</dt>
<dd><p>Bit 17 (VM) must be cleared. Bit 9 (IF) must be cleared. Other bits
are all undefined.
</p></dd>
</dl>

<p>All other processor registers and flag bits are undefined. This
includes, in particular:
</p>
<dl compact="compact">
<dt> &lsquo;<samp>ESP</samp>&rsquo;</dt>
<dd><p>The OS image must create its own stack as soon as it needs one.
</p>
</dd>
<dt> &lsquo;<samp>GDTR</samp>&rsquo;</dt>
<dd><p>Even though the segment registers are set up as described above, the
&lsquo;<samp>GDTR</samp>&rsquo; may be invalid, so the OS image must not load any segment
registers (even just reloading the same values!) until it sets up its
own &lsquo;<samp>GDT</samp>&rsquo;.
</p>
</dd>
<dt> &lsquo;<samp>IDTR</samp>&rsquo;</dt>
<dd><p>The OS image must leave interrupts disabled until it sets up its own
<code>IDT</code>.
</p></dd>
</dl>

<p>However, other machine state should be left by the boot loader in
<em>normal working order</em>, i.e. as initialized by the <small>BIOS</small> (or
DOS, if that's what the boot loader runs from). In other words, the
operating system should be able to make <small>BIOS</small> calls and such after
being loaded, as long as it does not overwrite the <small>BIOS</small> data
structures before doing so. Also, the boot loader must leave the
<small>PIC</small> programmed with the normal <small>BIOS</small>/DOS values, even if it
changed them during the switch to 32-bit mode.
</p>

<hr size="6">
<a name="Boot-information-format"></a>
<a name="SEC17"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC16" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="multiboot_4.html#SEC18" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC10" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC10" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="multiboot_4.html#SEC18" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="multiboot.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_6.html#SEC30" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.3 Boot information format </h2>

<p>FIXME: Split this chapter like the chapter &ldquo;OS image format&rdquo;.
</p>
<p>Upon entry to the operating system, the <code>EBX</code> register contains the
physical address of a <em>Multiboot information</em> data structure,
through which the boot loader communicates vital information to the
operating system. The operating system can use or ignore any parts of
the structure as it chooses; all information passed by the boot loader
is advisory only.
</p>
<p>The Multiboot information structure and its related substructures may be
placed anywhere in memory by the boot loader (with the exception of the
memory reserved for the kernel and boot modules, of course). It is the
operating system's responsibility to avoid overwriting this memory until
it is done using it.
</p>
<p>The format of the Multiboot information structure (as defined so far)
follows:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">        +-------------------+
0       | flags             |    (required)
        +-------------------+
4       | mem_lower         |    (present if flags[0] is set)
8       | mem_upper         |    (present if flags[0] is set)
        +-------------------+
12      | boot_device       |    (present if flags[1] is set)
        +-------------------+
16      | cmdline           |    (present if flags[2] is set)
        +-------------------+
20      | mods_count        |    (present if flags[3] is set)
24      | mods_addr         |    (present if flags[3] is set)
        +-------------------+
28 - 40 | syms              |    (present if flags[4] or
        |                   |                flags[5] is set)
        +-------------------+
44      | mmap_length       |    (present if flags[6] is set)
48      | mmap_addr         |    (present if flags[6] is set)
        +-------------------+
52      | drives_length     |    (present if flags[7] is set)
56      | drives_addr       |    (present if flags[7] is set)
        +-------------------+
60      | config_table      |    (present if flags[8] is set)
        +-------------------+
64      | boot_loader_name  |    (present if flags[9] is set)
        +-------------------+
68      | apm_table         |    (present if flags[10] is set)
        +-------------------+
72      | vbe_control_info  |    (present if flags[11] is set)
76      | vbe_mode_info     |
80      | vbe_mode          |
82      | vbe_interface_seg |
84      | vbe_interface_off |
86      | vbe_interface_len |
        +-------------------+
</pre></td></tr></table>

<p>The first longword indicates the presence and validity of other fields
in the Multiboot information structure. All as-yet-undefined bits must
be set to zero by the boot loader. Any set bits that the operating
system does not understand should be ignored. Thus, the &lsquo;<samp>flags</samp>&rsquo;
field also functions as a version indicator, allowing the Multiboot
information structure to be expanded in the future without breaking
anything.
</p>
<p>If bit 0 in the &lsquo;<samp>flags</samp>&rsquo; word is set, then the &lsquo;<samp>mem_*</samp>&rsquo; fields
are valid. &lsquo;<samp>mem_lower</samp>&rsquo; and &lsquo;<samp>mem_upper</samp>&rsquo; indicate the amount of
lower and upper memory, respectively, in kilobytes. Lower memory starts
at address 0, and upper memory starts at address 1 megabyte. The maximum
possible value for lower memory is 640 kilobytes. The value returned for
upper memory is maximally the address of the first upper memory hole
minus 1 megabyte. It is not guaranteed to be this value.
</p>
<p>If bit 1 in the &lsquo;<samp>flags</samp>&rsquo; word is set, then the &lsquo;<samp>boot_device</samp>&rsquo;
field is valid, and indicates which <small>BIOS</small> disk device the boot
loader loaded the OS image from. If the OS image was not loaded from a
<small>BIOS</small> disk, then this field must not be present (bit 3 must be
clear). The operating system may use this field as a hint for
determining its own <em>root</em> device, but is not required to. The
&lsquo;<samp>boot_device</samp>&rsquo; field is laid out in four one-byte subfields as
follows:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">+-------+-------+-------+-------+
| part3 | part2 | part1 | drive |
+-------+-------+-------+-------+
</pre></td></tr></table>

<p>The first byte contains the <small>BIOS</small> drive number as understood by the
<small>BIOS</small> INT 0x13 low-level disk interface: e.g. 0x00 for the first
floppy disk or 0x80 for the first hard disk.
</p>
<p>The three remaining bytes specify the boot partition. &lsquo;<samp>part1</samp>&rsquo;
specifies the <em>top-level</em> partition number, &lsquo;<samp>part2</samp>&rsquo; specifies a
<em>sub-partition</em> in the top-level partition, etc. Partition numbers
always start from zero. Unused partition bytes must be set to 0xFF. For
example, if the disk is partitioned using a simple one-level DOS
partitioning scheme, then &lsquo;<samp>part1</samp>&rsquo; contains the DOS partition
number, and &lsquo;<samp>part2</samp>&rsquo; and &lsquo;<samp>part3</samp>&rsquo; are both 0xFF. As another
example, if a disk is partitioned first into DOS partitions, and then
one of those DOS partitions is subdivided into several BSD partitions
using BSD's <em>disklabel</em> strategy, then &lsquo;<samp>part1</samp>&rsquo; contains the DOS
partition number, &lsquo;<samp>part2</samp>&rsquo; contains the BSD sub-partition within
that DOS partition, and &lsquo;<samp>part3</samp>&rsquo; is 0xFF.
</p>
<p>DOS extended partitions are indicated as partition numbers starting from
4 and increasing, rather than as nested sub-partitions, even though the
underlying disk layout of extended partitions is hierarchical in
nature. For example, if the boot loader boots from the second extended
partition on a disk partitioned in conventional DOS style, then
&lsquo;<samp>part1</samp>&rsquo; will be 5, and &lsquo;<samp>part2</samp>&rsquo; and &lsquo;<samp>part3</samp>&rsquo; will both be
0xFF.
</p>
<p>If bit 2 of the &lsquo;<samp>flags</samp>&rsquo; longword is set, the &lsquo;<samp>cmdline</samp>&rsquo; field
is valid, and contains the physical address of the command line to
be passed to the kernel. The command line is a normal C-style
zero-terminated string.
</p>
<p>If bit 3 of the &lsquo;<samp>flags</samp>&rsquo; is set, then the &lsquo;<samp>mods</samp>&rsquo; fields
indicate to the kernel what boot modules were loaded along with the
kernel image, and where they can be found. &lsquo;<samp>mods_count</samp>&rsquo; contains
the number of modules loaded; &lsquo;<samp>mods_addr</samp>&rsquo; contains the physical
address of the first module structure. &lsquo;<samp>mods_count</samp>&rsquo; may be zero,
indicating no boot modules were loaded, even if bit 1 of &lsquo;<samp>flags</samp>&rsquo; is
set. Each module structure is formatted as follows:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">        +-------------------+
0       | mod_start         |
4       | mod_end           |
        +-------------------+
8       | string            |
        +-------------------+
12      | reserved (0)      |
        +-------------------+
</pre></td></tr></table>

<p>The first two fields contain the start and end addresses of the boot
module itself. The &lsquo;<samp>string</samp>&rsquo; field provides an arbitrary string to
be associated with that particular boot module; it is a zero-terminated
ASCII string, just like the kernel command line. The &lsquo;<samp>string</samp>&rsquo; field
may be 0 if there is no string associated with the module. Typically the
string might be a command line (e.g. if the operating system treats boot
modules as executable programs), or a pathname (e.g. if the operating
system treats boot modules as files in a file system), but its exact use
is specific to the operating system. The &lsquo;<samp>reserved</samp>&rsquo; field must be
set to 0 by the boot loader and ignored by the operating system.
</p>
<p><strong>Caution:</strong> Bits 4 &amp; 5 are mutually exclusive.
</p>
<p>If bit 4 in the &lsquo;<samp>flags</samp>&rsquo; word is set, then the following fields in
the Multiboot information structure starting at byte 28 are valid:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">        +-------------------+
28      | tabsize           |
32      | strsize           |
36      | addr              |
40      | reserved (0)      |
        +-------------------+
</pre></td></tr></table>

<p>These indicate where the symbol table from an a.out kernel image can be
found. &lsquo;<samp>addr</samp>&rsquo; is the physical address of the size (4-byte unsigned
long) of an array of a.out format <em>nlist</em> structures, followed
immediately by the array itself, then the size (4-byte unsigned long) of
a set of zero-terminated <small>ASCII</small> strings (plus sizeof(unsigned long) in
this case), and finally the set of strings itself. &lsquo;<samp>tabsize</samp>&rsquo; is
equal to its size parameter (found at the beginning of the symbol
section), and &lsquo;<samp>strsize</samp>&rsquo; is equal to its size parameter (found at
the beginning of the string section) of the following string table to
which the symbol table refers. Note that &lsquo;<samp>tabsize</samp>&rsquo; may be 0,
indicating no symbols, even if bit 4 in the &lsquo;<samp>flags</samp>&rsquo; word is set.
</p>
<p>If bit 5 in the &lsquo;<samp>flags</samp>&rsquo; word is set, then the following fields in
the Multiboot information structure starting at byte 28 are valid:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">        +-------------------+
28      | num               |
32      | size              |
36      | addr              |
40      | shndx             |
        +-------------------+
</pre></td></tr></table>

<p>These indicate where the section header table from an ELF kernel is, the
size of each entry, number of entries, and the string table used as the
index of names. They correspond to the &lsquo;<samp>shdr_*</samp>&rsquo; entries
(&lsquo;<samp>shdr_num</samp>&rsquo;, etc.) in the Executable and Linkable Format (<small>ELF</small>)
specification in the program header. All sections are loaded, and the
physical address fields of the <small>ELF</small> section header then refer to where
the sections are in memory (refer to the i386 <small>ELF</small> documentation for
details as to how to read the section header(s)). Note that
&lsquo;<samp>shdr_num</samp>&rsquo; may be 0, indicating no symbols, even if bit 5 in the
&lsquo;<samp>flags</samp>&rsquo; word is set.
</p>
<p>If bit 6 in the &lsquo;<samp>flags</samp>&rsquo; word is set, then the &lsquo;<samp>mmap_*</samp>&rsquo; fields
are valid, and indicate the address and length of a buffer containing a
memory map of the machine provided by the <small>BIOS</small>. &lsquo;<samp>mmap_addr</samp>&rsquo; is
the address, and &lsquo;<samp>mmap_length</samp>&rsquo; is the total size of the buffer. The
buffer consists of one or more of the following size/structure pairs
(&lsquo;<samp>size</samp>&rsquo; is really used for skipping to the next pair):
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">        +-------------------+
-4      | size              |
        +-------------------+
0       | base_addr_low     |
4       | base_addr_high    |
8       | length_low        |
12      | length_high       |
16      | type              |
        +-------------------+
</pre></td></tr></table>

<p>where &lsquo;<samp>size</samp>&rsquo; is the size of the associated structure in bytes, which
can be greater than the minimum of 20 bytes. &lsquo;<samp>base_addr_low</samp>&rsquo; is the
lower 32 bits of the starting address, and &lsquo;<samp>base_addr_high</samp>&rsquo; is the
upper 32 bits, for a total of a 64-bit starting address. &lsquo;<samp>length_low</samp>&rsquo;
is the lower 32 bits of the size of the memory region in bytes, and
&lsquo;<samp>length_high</samp>&rsquo; is the upper 32 bits, for a total of a 64-bit
length. &lsquo;<samp>type</samp>&rsquo; is the variety of address range represented, where a
value of 1 indicates available <small>RAM</small>, and all other values currently
indicated a reserved area.
</p>
<p>The map provided is guaranteed to list all standard <small>RAM</small> that should
be available for normal use.
</p>
<p>If bit 7 in the &lsquo;<samp>flags</samp>&rsquo; is set, then the &lsquo;<samp>drives_*</samp>&rsquo; fields
are valid, and indicate the address of the physical address of the first
drive structure and the size of drive structures. &lsquo;<samp>drives_addr</samp>&rsquo;
is the address, and &lsquo;<samp>drives_length</samp>&rsquo; is the total size of drive
structures. Note that &lsquo;<samp>drives_length</samp>&rsquo; may be zero. Each drive
structure is formatted as follows:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">        +-------------------+
0       | size              |
        +-------------------+
4       | drive_number      |
        +-------------------+
5       | drive_mode        |
        +-------------------+
6       | drive_cylinders   |
8       | drive_heads       |
9       | drive_sectors     |
        +-------------------+
10 - xx | drive_ports       |
        +-------------------+
</pre></td></tr></table>

<p>The &lsquo;<samp>size</samp>&rsquo; field specifies the size of this structure. The size
varies, depending on the number of ports. Note that the size may not be
equal to (10 + 2 * the number of ports), because of an alignment.
</p>
<p>The &lsquo;<samp>drive_number</samp>&rsquo; field contains the BIOS drive number. The
&lsquo;<samp>drive_mode</samp>&rsquo; field represents the access mode used by the boot
loader. Currently, the following modes are defined:
</p>
<dl compact="compact">
<dt> &lsquo;<samp>0</samp>&rsquo;</dt>
<dd><p>CHS mode (traditional cylinder/head/sector addressing mode).
</p>
</dd>
<dt> &lsquo;<samp>1</samp>&rsquo;</dt>
<dd><p>LBA mode (Logical Block Addressing mode).
</p></dd>
</dl>

<p>The three fields, &lsquo;<samp>drive_cylinders</samp>&rsquo;, &lsquo;<samp>drive_heads</samp>&rsquo; and
&lsquo;<samp>drive_sectors</samp>&rsquo;, indicate the geometry of the drive detected by the
<small>BIOS</small>. &lsquo;<samp>drive_cylinders</samp>&rsquo; contains the number of the
cylinders. &lsquo;<samp>drive_heads</samp>&rsquo; contains the number of the
heads. &lsquo;<samp>drive_sectors</samp>&rsquo; contains the number of the sectors per
track.
</p>
<p>The &lsquo;<samp>drive_ports</samp>&rsquo; field contains the array of the I/O ports used
for the drive in the <small>BIOS</small> code. The array consists of zero or more
unsigned two-bytes integers, and is terminated with zero. Note that the
array may contain any number of I/O ports that are not related to the
drive actually (such as <small>DMA</small> controller's ports).
</p>
<p>If bit 8 in the &lsquo;<samp>flags</samp>&rsquo; is set, then the &lsquo;<samp>config_table</samp>&rsquo; field
is valid, and indicates the address of the <small>ROM</small> configuration table
returned by the <em>GET CONFIGURATION</em> <small>BIOS</small> call. If the <small>BIOS</small>
call fails, then the size of the table must be <em>zero</em>.
</p>
<p>If bit 9 in the &lsquo;<samp>flags</samp>&rsquo; is set, the &lsquo;<samp>boot_loader_name</samp>&rsquo; field
is valid, and contains the physical address of the name of a boot
loader booting the kernel. The name is a normal C-style zero-terminated
string.
</p>
<p>If bit 10 in the &lsquo;<samp>flags</samp>&rsquo; is set, the &lsquo;<samp>apm_table</samp>&rsquo; field is
valid, and contains the physical address of an <small>APM</small> table defined as
below:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">        +----------------------+
0       | version              |
2       | cseg                 |
4       | offset               |
8       | cseg_16              |
10      | dseg                 |
12      | flags                |
14      | cseg_len             |
16      | cseg_16_len          |
18      | dseg_len             |
        +----------------------+
</pre></td></tr></table>

<p>The fields &lsquo;<samp>version</samp>&rsquo;, &lsquo;<samp>cseg</samp>&rsquo;, &lsquo;<samp>offset</samp>&rsquo;, &lsquo;<samp>cseg_16</samp>&rsquo;,
&lsquo;<samp>dseg</samp>&rsquo;, &lsquo;<samp>flags</samp>&rsquo;, &lsquo;<samp>cseg_len</samp>&rsquo;, &lsquo;<samp>cseg_16_len</samp>&rsquo;,
&lsquo;<samp>dseg_len</samp>&rsquo; indicate the version number, the protected mode 32-bit
code segment, the offset of the entry point, the protected mode 16-bit
code segment, the protected mode 16-bit data segment, the flags, the
length of the protected mode 32-bit code segment, the length of the
protected mode 16-bit code segment, and the length of the protected mode
16-bit data segment, respectively. Only the field &lsquo;<samp>offset</samp>&rsquo; is 4
bytes, and the others are 2 bytes. See
<a href="http://www.microsoft.com/hwdev/busbios/amp_12.htm">Advanced Power Management (APM) BIOS Interface Specification</a>, for more information.
</p>
<p>If bit 11 in the &lsquo;<samp>flags</samp>&rsquo; is set, the graphics table is available.
This must only be done if the kernel has indicated in the
&lsquo;<samp>Multiboot Header</samp>&rsquo; that it accepts a graphics mode.
</p>
<p>The fields &lsquo;<samp>vbe_control_info</samp>&rsquo; and &lsquo;<samp>vbe_mode_info</samp>&rsquo; contain
the physical addresses of <small>VBE</small> control information returned by the
<small>VBE</small> Function 00h and <small>VBE</small> mode information returned by the
<small>VBE</small> Function 01h, respectively.
</p>
<p>The field &lsquo;<samp>vbe_mode</samp>&rsquo; indicates current video mode in the format
specified in <small>VBE</small> 3.0.
</p>
<p>The rest fields &lsquo;<samp>vbe_interface_seg</samp>&rsquo;, &lsquo;<samp>vbe_interface_off</samp>&rsquo;, and
&lsquo;<samp>vbe_interface_len</samp>&rsquo; contain the table of a protected mode interface
defined in <small>VBE</small> 2.0+. If this information is not available, those
fields contain zero. Note that <small>VBE</small> 3.0 defines another protected
mode interface which is incompatible with the old one. If you want to
use the new protected mode interface, you will have to find the table
yourself.
</p>
<p>The fields for the graphics table are designed for <small>VBE</small>, but
Multiboot boot loaders may simulate <small>VBE</small> on non-<small>VBE</small> modes, as
if they were <small>VBE</small> modes.
</p>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC10" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="multiboot_4.html#SEC18" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="multiboot.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_6.html#SEC30" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="multiboot_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>root</em> on <em>March, 20 2010</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.78</em></a>.
 </font>
 <br>

</p>
</body>
</html>
